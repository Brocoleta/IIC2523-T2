Practical Byzantine Fault Tolerance, habla sobre un algoritmo en respuesta a las fallas por errores bizantinos, errores en los cuales algún componente ha fallado y entrega información imprecisa que se cree que es verdadera.
Antes ya se habían propuesto algoritmos para resolver este problema, los cuales lo resuelven teóricamente, pero en la practica no son implementados, debido a que son muy ineficientes, y se basan en varios supuestos, como la velocidad de los mensajes y la sincronía de procesos. Esto es un peligro, debido a que un atacante podría retrasar mensajes o retrasar nodos correctos, y coordinar los defectuosos, y asi lograr dañar a la red.
Por esto el algoritmo propuesto en el paper se basa en la asincronía, de esta manera los nodos son independientes y sus fallas no afectan a otros. También utiliza criptografía, para evitar que los atacantes produzcan firmas de nodos no defectuosos y hacerse pasar por ellos, como también para no revelar información acerca de los nodos. Para autenticar las firmas se ocupa message authentication code (MAC), el cual tiene una complejidad lineal, lo cual supone una ventaja ya que en la practica los autentificadores funcionan más rápido que las firmas digitales. La única limitación que tiene a comparación de esta, es que no se puede comprobar que un mensaje es autentico para un tercero, pero el algoritmo maneja esto modificándolo de manera que no hallan dos solicitudes diferentes que tengan el mismo numero de secuencia y vista.
Los pasos que sigue el algoritmo son los siguientes:

1. Primero a partir del número máximo de nodos corruptos “f”, se define la cantidad de nodos a necesitar para asegurar la correctitud del algoritmo, que vendría siendo R=3f + 1.
2. Se definen las vistas, que son las configuraciones por donde se mueven las réplicas, la vista se calcula según p=v mod R, donde p es el id del nodo con el cual se comunican directamente los clientes de la vista, a este se le llama nodo primario. Las vistas están organizadas con nodos primarios, para que cuando se detecte un fallo, los nodos se reorganicen para que otro nodo que no tenga fallos pase a ser el primario.
3. Cuando un cliente envía una solicitud, esta recibe una replica primaria, la cual envía a otras replicas que se ejecutan y le responden al cliente. El cliente esperara a que hallan f + 1 respuestas iguales de diferentes replicas, el cual será el resultado de la request, asi se asegura que la respuesta fue enviada por replicas no dañadas, debido al parámetro f definido anteriormente.

Con mas detalle, lo que pasa cuando llega una nueva request, se divide en tres fases: pre-prepare, prepare y commits.
En pre-prepare, el nodo primario le asigna a la request un numero de secuencia, y envía un mensaje a todos los otros nodos. Los nodos aceptan estos mensajes solo si el valor de la vista del mensaje enviado coincide con el suyo, y no ha aceptado otro mensaje con el mismo número de secuencia. Cuando esto pasa, el nodo pasa a la fase prepare, y hace multicast a todos los otros nodos de su réplica, aceptan estos mensajes si coinciden con su vista. En estas dos fases, se asegura que las replicas no defectuosas tengan el mismo orden que las request recibidas en una vista, para pasar de la fase prepare, se necesita haber recibido 2f prepare para asegurar lo mencionado antes.
Cuando se pasa a la fase commit, se envía un mensaje a los nodos replicas para que se ejecuten, para esto tienen que esperar a haber recibido 2f + 1 commits, para asegurar que no sea defectuoso, y no se ejecuten en el mismo orden que las requests anteriores. Una vez se finaliza commit, se envía una respuesta al cliente, y una vez que el cliente recibe f+1 respuestas iguales, se considera correcta la respuesta.
El algoritmo utiliza dos métricas para medir su funcionamiento, la prueba Andrew y la micro prueba. La prueba Andrew consiste en comparar el algoritmo con dos sistemas de archivos ya implementados, y además evalúa como se comporta el algoritmo en un servicio implementado. Por otro lado, la micro prueba consiste en simplemente medir la latencia.
